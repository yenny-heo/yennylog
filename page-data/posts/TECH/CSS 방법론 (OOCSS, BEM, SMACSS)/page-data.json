{
    "componentChunkName": "component---src-components-templates-post-index-js",
    "path": "/posts/TECH/CSS 방법론 (OOCSS, BEM, SMACSS)/",
    "result": {"data":{"markdownRemark":{"html":"<h3 id=\"1-oocss-object-oriented-css\" style=\"position:relative;\"><a href=\"#1-oocss-object-oriented-css\" aria-label=\"1 oocss object oriented css permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. OOCSS (Object Oriented CSS)</h3>\n<p>중복을 최소화, 캡슐화를 원칙으로 하는 방식</p>\n<ol>\n<li>구조와 외형 분리\n<ul>\n<li>구조: width, height, border, padding, margin ...</li>\n<li>외형: color, border-color, font-color, background-color ...</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"language-css\">&#x3C;div\r\n  class=\"btn common-skin tel\"\r\n  > tel&#x3C;/div\r\n  > &#x3C;div\r\n  class=\"btn common-skin email\"\r\n  > email&#x3C;/div\r\n  > .btn {\r\n}\r\n.common-skin {\r\n}\n</code></pre>\n<ol>\n<li>컨테이너와 내용 분리\n<ul>\n<li>위치에 의존하지 않는 스타일 정의</li>\n<li>어떤 태그라도 동일한 외형 제공</li>\n<li>어디서나 재사용이 가능한 클래스 기반 구축</li>\n</ul>\n</li>\n</ol>\n<pre><code class=\"language-css\">// Bad\r\nh3 {\r\n  font-size: 16px;\r\n}\r\n// Good\r\n.sub-title {\r\n  font-size: 16px;\r\n}\n</code></pre>\n<ul>\n<li>장점:\n<ul>\n<li>공통된 부분 정의해서 재사용 가능 ⇒ 코드 양 줄어듦</li>\n<li>동일한 클래스라면 동일한 스타일 기대 가능</li>\n</ul>\n</li>\n<li>단점:\n<ul>\n<li>공통된 클래스가 많아, 수정이 필요할 시 멀티클래스 사용해야함.</li>\n<li>멀티클래스가 많아짐에 따라 유지보수 어려움</li>\n<li>가독성 떨어짐</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-bem-block-element-modifier\" style=\"position:relative;\"><a href=\"#2-bem-block-element-modifier\" aria-label=\"2 bem block element modifier permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. BEM (Block Element Modifier)</h3>\n<p>Block, Element, Modifier로 나누어서 클래스명을 기술하는 방법</p>\n<ul>\n<li><code>block__element—modifier</code></li>\n<li>ID에는 사용할 수 없고 오직 클래스명에만 사용할 수 있음.</li>\n<li>Selector만으로도 어디에 어떻게 사용되는지 유추 가능하도록 작성</li>\n</ul>\n<ol>\n<li>Block: 재사용 가능한 영역, 하나의 단어를 사용하되 길어질 경우 하이픈(-) 사용</li>\n</ol>\n<pre><code class=\"language-css\">.header {\r\n  ...;\r\n}\r\n.block {\r\n  ...;\r\n}\n</code></pre>\n<ol>\n<li>Element: 블록의 내부 구성을 표현, 두 개의 언더스코어(__)로 표기</li>\n</ol>\n<pre><code class=\"language-css\">.header {\r\n  ...;\r\n}\r\n.header__link {\r\n  ...;\r\n}\r\n.header__tap {\r\n  ...;\r\n}\r\n.header__tap__item {\r\n  ...;\r\n}\n</code></pre>\n<ol>\n<li>Modifier: 요소의 상태를 표현, 두 개의 하이픈(—)으로 표기</li>\n</ol>\n<pre><code class=\"language-css\">.header--hide {\r\n  ...;\r\n}\r\n.header__tap--big {\r\n  ...;\r\n}\r\n.header__tap--big {\r\n  ...;\r\n}\n</code></pre>\n<ul>\n<li>장점:\n<ul>\n<li>직관적인 클래스 명으로 구조파악 쉬움</li>\n</ul>\n</li>\n<li>단점:\n<ul>\n<li>클래스명이 길어질 수 밖에 없어 코드가 길어지고 복잡해짐</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-smacss-scalable-modular-architecture-css\" style=\"position:relative;\"><a href=\"#3-smacss-scalable-modular-architecture-css\" aria-label=\"3 smacss scalable modular architecture css permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. SMACSS (Scalable Modular Architecture CSS)</h3>\n<p>범주화로 패턴화 하고자 하는 방법론</p>\n<p>기본(base), 레이아웃(layout), 모듈(module), 상태(state), 테마(theme)</p>\n<p>다섯가지의 범주 제시</p>\n<ol>\n<li>base ⇒ 스타일 초기화 (reset.css)</li>\n</ol>\n<pre><code class=\"language-css\">body,\r\np,\r\ntable,\r\nform,\r\nfieldset,\r\nlegend,\r\ninput,\r\nbutton ... {\r\n  margin: 0;\r\n  padding: 0;\r\n}\n</code></pre>\n<ol>\n<li>layout ⇒ 주요 요소(id), 하위 요소(class)로 구분하고 접두사를 사용\n<ol>\n<li>주요 컴포넌트: header, footer, aside, container 등</li>\n<li>하위 컴포넌트: list, item, form 등</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-css\">// 주요 요소 ()\r\n#header {\r\n  width: 400px;\r\n}\r\n#aside {\r\n  width: 30px;\r\n}\r\n// 하위 요소 (layout => l-)\r\n.l-width #header {\r\n  width: 600px;\r\n  padding: 10px;\r\n}\r\n.l-width #aside {\r\n  width: 100px;\r\n}\n</code></pre>\n<ol>\n<li>module ⇒ 재사용 가능한 구성요소: 버튼, 배너, 아이콘 등</li>\n</ol>\n<pre><code class=\"language-css\">.stick {\r\n  ...;\r\n}\r\n.stick-name {\r\n  ...;\r\n}\r\n.stick-number {\r\n  ...;\r\n}\n</code></pre>\n<ol>\n<li>state ⇒ 요소의 상태변화를 표현하고 접두사를 사용</li>\n</ol>\n<pre><code class=\"language-css\">.is-error {\r\n  ...;\r\n}\r\n.is-hidden {\r\n  ...;\r\n}\r\n.is-disabled {\r\n  ...;\r\n}\n</code></pre>\n<ol>\n<li>theme ⇒ 사용자가 선택 가능하도록 스타일을 재선언하여 사용</li>\n</ol>\n<pre><code class=\"language-css\">// base.css\r\n.header {\r\n  background-color: green;\r\n}\r\n// theme.css\r\n.header {\r\n  background-color: red;\r\n}\n</code></pre>\n<ul>\n<li>장점:\n<ul>\n<li>클래스명을 통한 예측의 용이성</li>\n<li>재사용을 통한 코드의 간결화</li>\n<li>확장의 용이성</li>\n</ul>\n</li>\n<li>단점:\n<ul>\n<li>카테고리를 나누는 기준이 불분명해질 수 있음</li>\n<li>코드를 나눠서 작성해야 해서 CSS 사용하기 번거로움</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"CSS 방법론 (OOCSS, BEM, SMACSS)","date":"2022-05-23","tags":["CSS"],"type":"TECH"},"tableOfContents":"<ul>\n<li><a href=\"#1-oocss-object-oriented-css\">1. OOCSS (Object Oriented CSS)</a></li>\n<li><a href=\"#2-bem-block-element-modifier\">2. BEM (Block Element Modifier)</a></li>\n<li><a href=\"#3-smacss-scalable-modular-architecture-css\">3. SMACSS (Scalable Modular Architecture CSS)</a></li>\n</ul>"}},"pageContext":{"slug":"/posts/TECH/CSS 방법론 (OOCSS, BEM, SMACSS)/"}},
    "staticQueryHashes": ["3649515864","63159454"]}