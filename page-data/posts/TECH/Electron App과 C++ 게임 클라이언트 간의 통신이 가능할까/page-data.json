{"componentChunkName":"component---src-components-templates-post-index-js","path":"/posts/TECH/Electron App과 C++ 게임 클라이언트 간의 통신이 가능할까/","result":{"data":{"markdownRemark":{"html":"<p>C++ 게임 클라이언트 ↔ Electron App 간의 통신을 시나리오로 잡았다.</p>\n<p>게임 클라이언트와 일렉트론 앱이 어떤 방식으로 통신을 할지는 아직 명확하지가 않아서 우선은 ‘양방향’에 초점을 맞추고 서로 데이터를 주고 받을 수 있는지에 대해 확인을 해보았다.</p>\n<h2 id=\"tcpip-socket\" style=\"position:relative;\"><a href=\"#tcpip-socket\" aria-label=\"tcpip socket permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP/IP Socket</h2>\n<p>통신을 하는 방법은 TCP/IP 소켓 프로그래밍을 이용해보기로 했다.</p>\n<p>Server 소켓과 Client 소켓을 만들고, 같은 IP 주소, port를 통해 두 소켓을 연결하여 통신하는 방식이다.</p>\n<p>이때 서버와 클라이언트는 유일한 IP주소와 port 조합을 가져야 한다.</p>\n<h2 id=\"electron---server\" style=\"position:relative;\"><a href=\"#electron---server\" aria-label=\"electron   server permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Electron - Server</h2>\n<p>일렉트론은 <code>node</code> 기반이기 때문에, <code>node</code>의 <code>net</code> 모듈로 서버를 열어보기로 했다.</p>\n<p>7777번 host에 서버를 열었다. 서버는 클라이언트로부터 데이터를 받고, 그 데이터를 그대로 보내준다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">var server = net.createServer(function (client) {\r\n    client.setEncoding(&quot;utf8&quot;);\r\n    client.setTimeout(500);\r\n    client.on(&quot;data&quot;, function (data) {\r\n      for (var i = 0; i &lt; sockets.length; i++) {\r\n        sockets[i].write(`Hi, I&#39;m server and received &quot;${data}&quot;`);\r\n      }\r\n    });\r\n    client.on(&quot;error&quot;, function () {\r\n      console.log(&quot;error&quot;);\r\n    });\r\n    client.on(&quot;close&quot;, function () {\r\n      sockets.pop();\r\n      console.log(&quot;client close&quot;);\r\n    });\r\n    client.on(&quot;timeout&quot;, function () {});\r\n    sockets.push(client);\r\n  });\r\n\r\n  server.on(&quot;error&quot;, function (error) {});\r\n  server.listen(7777, function () {\r\n    var serverInfo = server.address();\r\n    var serverInfoJson = JSON.stringify(serverInfo);\r\n    console.log(&quot;listen server : &quot; + serverInfoJson);\r\n    server.on(&quot;close&quot;, function () {\r\n      console.log(&quot;server closed.&quot;);\r\n    });\r\n    server.on(&quot;connection&quot;, function () {\r\n      console.log(&quot;connected!!!&quot;);\r\n    });\r\n  });\r\n});</code>\n        </deckgo-highlight-code>\n<h2 id=\"c---client\" style=\"position:relative;\"><a href=\"#c---client\" aria-label=\"c   client permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>C++ - Client</h2>\n<p>C++에서는 소켓 프로그래밍을 위한 헤더 winsock2.h를 추가하여 클라이언트를 생성하였다.</p>\n<p>IP: 127.0.0.1, port: 7777로 소켓을 연결하여 메시지를 입력해서 서버에 전송하고, 서버로부터 데이터를 받아 출력해준다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">#define _WINSOCK_DEPRECATED_NO_WARNINGS\r\n#include&lt;iostream&gt;\r\n#include&lt;string&gt;\r\n#include&lt;winsock2.h&gt;\r\n\r\nusing namespace std;\r\nvoid ShowErrorMessage(string message)\r\n{\r\n\tcout &lt;&lt; &quot;[오류발생]: &quot; &lt;&lt; message &lt;&lt; &#39;\\n&#39;;\r\n\tsystem(&quot;pause&quot;);\r\n\texit(1);\r\n}\r\n\r\nint main()\r\n{\r\n\tWSADATA wsaData;\r\n\tSOCKET clientSocket;\r\n\tSOCKADDR_IN serverAddress;\r\n\tint serverPort = 7777;\r\n\tchar received[256];\r\n\tstring sent;\r\n\tif (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) // Initialize Winsock\r\n\t\tShowErrorMessage(&quot;WSAStartup()&quot;);\r\n\tclientSocket = socket(PF_INET, SOCK_STREAM, 0); // Create TCP Client Socket\r\n\tif (clientSocket == INVALID_SOCKET)\r\n\t\tShowErrorMessage(&quot;socket()&quot;);\r\n\tmemset(&amp;serverAddress, 0, sizeof(serverAddress));\r\n\tserverAddress.sin_family = AF_INET;\r\n\tserverAddress.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);\r\n\tserverAddress.sin_port = htons(serverPort);\r\n\r\n\tif (connect(clientSocket, (SOCKADDR*)&amp;serverAddress, sizeof(serverAddress)) == SOCKET_ERROR)\r\n\t\tShowErrorMessage(&quot;connect()&quot;);\r\n\tcout &lt;&lt; &quot;[현재상태] connect()\\n&quot;;\r\n\twhile (1) { // Send and receive message from server repeatedly\r\n\t\tcout &lt;&lt; &quot;[메시지전송]: &quot;;\r\n\t\tgetline(cin, sent);\r\n\t\tif (sent == &quot;&quot;) continue;\r\n\t\tsend(clientSocket, sent.c_str(), sent.length(), 0);\r\n\t\tint length = recv(clientSocket, received, sizeof(received), 0);\r\n\t\treceived[length] = &#39;\\0&#39;;\r\n\t\tif (strcmp(received, &quot;[exit]&quot;) == 0) {\r\n\t\t\tcout &lt;&lt; &quot;[서버종료]\\n&quot;;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcout &lt;&lt; &quot;[서버메시지]: &quot; &lt;&lt; received &lt;&lt; &#39;\\n&#39;;\r\n\t}\r\n\tclosesocket(clientSocket);\r\n\tWSACleanup();\r\n\tsystem(&quot;pause&quot;);\r\n\treturn 0;\r\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"연결하기\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"연결하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연결하기</h2>\n<p>이제 준비는 다 되었다. Server를 먼저 열고, 그다음 Client를 열어 연결해주면 된다.</p>\n<p>Electron App의 모습 (Server)</p>\n<p>C++ 콘솔창의 모습 (Client)</p>\n<p>성공적으로 연결된 것을 확인할 수 있었다. 그렇다면 데이터를 주고 받아보자.</p>\n<p>양방향 통신 또한 아주 잘 되는 모습이었다.</p>\n<p>결론은, <strong>Electron 앱과 C++ 게임 클라이언트는 TCP/IP 소켓 통신을 통해 데이터를 주고받을 수 있다.</strong></p>\n<p><strong>+</strong></p>\n<p>찾아본 결과 gRPC (google Remote Procedure Cell) 로도 통신이 가능하다고 합니다.</p>\n<h2 id=\"참조\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조</h2>\n<p><a href=\"https://ryeom2.tistory.com/117\">https://ryeom2.tistory.com/117</a></p>\n<p><a href=\"https://stackoverflow.com/questions/41674063/is-it-possible-to-create-a-tcp-client-with-electron\">https://stackoverflow.com/questions/41674063/is-it-possible-to-create-a-tcp-client-with-electron</a></p>","frontmatter":{"title":"Electron App과 C++ 게임 클라이언트 간의 통신이 가능할까?","date":"2022-02-09","tags":["Electron","C++"],"type":"TECH"},"tableOfContents":"<ul>\n<li><a href=\"#tcpip-socket\">TCP/IP Socket</a></li>\n<li><a href=\"#electron---server\">Electron - Server</a></li>\n<li><a href=\"#c---client\">C++ - Client</a></li>\n<li><a href=\"#%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0\">연결하기</a></li>\n<li><a href=\"#%EC%B0%B8%EC%A1%B0\">참조</a></li>\n</ul>"}},"pageContext":{"slug":"/posts/TECH/Electron App과 C++ 게임 클라이언트 간의 통신이 가능할까/"}},"staticQueryHashes":["3649515864","63159454"]}