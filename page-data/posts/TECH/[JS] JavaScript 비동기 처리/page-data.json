{
    "componentChunkName": "component---src-components-templates-post-index-js",
    "path": "/posts/TECH/[JS] JavaScript 비동기 처리/",
    "result": {"data":{"markdownRemark":{"html":"<h1 id=\"잘못된-정보\" style=\"position:relative;\"><a href=\"#%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%A0%95%EB%B3%B4\" aria-label=\"잘못된 정보 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>잘못된 정보</h1>\n<blockquote>\n<p>문제: for await ... of는 반복문 내에서 일어나는 모든 비동기 구문을 기다려주는 구문이다 ?</p>\n</blockquote>\n<p>검색을 해보면 위와 같이 설명하는 글이 매우매우 많지만, 대부분 <strong>잘못된 정보</strong>이다.</p>\n<p>for await ... of는 비동기 구문을 기다려주는게 아니라, 단순히 <strong>비동기 열거</strong>를 위해 사용하는 구문이다.</p>\n<p>(출처: <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for-await...of\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for-await...of</a>)</p>\n<p>다음과 같이 Promise 객체를 반환하는 함수가 있다고 할 때,</p>\n<pre><code class=\"language-jsx\">const getPromisedObject = id => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => resolve({ message: \"success\", id }), 2000);\r\n  });\r\n};\n</code></pre>\n<p>비동기 루프문을 위해 아래와 같이 코드를 작성하는 것은 올바르지 않다.</p>\n<pre><code class=\"language-jsx\">const getPromisedObjects = async () => {\r\n  const resArray = [];\r\n  for await (let id of [1, 2, 3]) {\r\n    const res = await getPromisedObject(id);\r\n    resArray.push(res);\r\n  }\r\n  console.log(resArray);\r\n};\n</code></pre>\n<h1 id=\"비동기-처리-방법\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95\" aria-label=\"비동기 처리 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기 처리 방법</h1>\n<h2 id=\"비동기-작업-순차처리\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9E%91%EC%97%85-%EC%88%9C%EC%B0%A8%EC%B2%98%EB%A6%AC\" aria-label=\"비동기 작업 순차처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기 작업 순차처리</h2>\n<blockquote>\n<p>for, for ... of 를 사용</p>\n</blockquote>\n<p><strong>for</strong>문과 <strong>for ... of</strong> 문 내부에서 await 구문을 사용하기만 하더라도 비동기 처리가 순차적으로 이루어진다.</p>\n<pre><code class=\"language-jsx\">const getPromisedObjects = async () => {\r\n  const resArray = [];\r\n  for (let id of [1, 2, 3]) {\r\n    const res = await getPromisedObject(id);\r\n    resArray.push(res);\r\n  }\r\n  console.log(resArray);\r\n};\n</code></pre>\n<h2 id=\"비동기-작업-병렬처리\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9E%91%EC%97%85-%EB%B3%91%EB%A0%AC%EC%B2%98%EB%A6%AC\" aria-label=\"비동기 작업 병렬처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기 작업 병렬처리</h2>\n<blockquote>\n<p>Promise.all 를 사용</p>\n</blockquote>\n<p>순서가 중요하지 않은 비동기 작업의 병렬 처리를 하고 싶다면 <strong>Promise.all</strong>을 사용하면 된다.</p>\n<p>순차처리에서는 2초 * 3 = 6초가 걸렸지만, 병렬처리로는 2초 뒤 작업이 끝난다.</p>\n<pre><code class=\"language-jsx\">const getPromisedObjects = async () => {\r\n  const promises = [1, 2, 3].map(id => getPromisedObject(id));\r\n  const resArray = await Promise.all(promises);\r\n  console.log(resArray);\r\n};\n</code></pre>\n<h2 id=\"for-await--of는-언제-사용할까\" style=\"position:relative;\"><a href=\"#for-await--of%EB%8A%94-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\" aria-label=\"for await  of는 언제 사용할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>for await ... of는 언제 사용할까?</h2>\n<blockquote>\n<p>for await (variable of iterable) {\r\nstatement\r\n}</p>\n</blockquote>\n<p>비동기 열거형 처리를 위해 사용한다. <em>iterable</em>에 비동기 열거형이 들어가지 않는다면 사용할 필요가 없다.</p>\n<pre><code class=\"language-jsx\">const getPromisedObjects = async () => {\r\n  const resArray = [];\r\n  const promises = [1, 2, 3].map(id => getPromisedObject(id));\r\n  for await (let res of promises) {\r\n    resArray.push(res);\r\n  }\r\n  console.log(resArray);\r\n};\n</code></pre>","frontmatter":{"title":"[JS] JavaScript 비동기 처리","date":"2022-02-20","tags":["JavaScript"],"type":"TECH"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%A0%95%EB%B3%B4\">잘못된 정보</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95\">비동기 처리 방법</a></p>\n<ul>\n<li><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9E%91%EC%97%85-%EC%88%9C%EC%B0%A8%EC%B2%98%EB%A6%AC\">비동기 작업 순차처리</a></li>\n<li><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9E%91%EC%97%85-%EB%B3%91%EB%A0%AC%EC%B2%98%EB%A6%AC\">비동기 작업 병렬처리</a></li>\n<li><a href=\"#for-await--of%EB%8A%94-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\">for await ... of는 언제 사용할까?</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"slug":"/posts/TECH/[JS] JavaScript 비동기 처리/"}},
    "staticQueryHashes": ["3649515864","63159454"]}